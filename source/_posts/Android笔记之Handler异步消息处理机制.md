---
title: Android笔记之Handler异步消息处理机制
date: 2016-08-30 19:10:26
tags: Android
---


>主要参考文献：
深入理解Android，卷１
Android 5.0 源码
 http://blog.csdn.net/sodino/article/details/41946607

学识尚浅，错误之处请指正。

#####为什么需要JNI?
JNI(Java Native Interface的简称)，中文翻译为java本地调用接口，名字已经很形象的说明了这个技术的作用，就是支持java这种高级编程语言对本地函数的调用，主要包括C/C++等语言编写的函数。

<!-- more -->

那么对于Java而言，为什么设计这样一种技术去调用本地函数呢？理由是显而易见的：
- 操作系统是由C/C++实现的。
- 作为Java语言跨平台支持的Java虚拟机是由C/C++实现的,它使用C/C++屏蔽不同平台的实现，使用JNI提供Java编程接口。
- 因为虚拟机的存在，Java语言在性能要求较高的场景下并不适用，很多情况下要求整合C/C++模块一同使用。
- Java语言存在之初已经存在C/C++实现的优秀的功能和应用，没必要重复造轮子。

与此可见，JNI技术的出现是由于Java语言所处的境地和其自身的局限性必然要求。

对于Android而言，所有的android的学习者都曾经接触过这样的一张经典的android体系结构图。JNI是连接java层代码和Native层的关键桥梁，想要了解android，就无法避免时时处处与JNI打交道。

![typical-schematic-of-android_structure.png
图片来源：http://www.cubrid.org/blog/dev-platform/android-at-a-glance](http://upload-images.jianshu.io/upload_images/1806858-545f5315f0e77760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

####Android Studio中JNI的简单使用
<p>
#####1. java代码加载库和声明
首先不得不说，JNI对Java程序员来说是非常宽容和仁慈的，因为在Java中使用JNI调用本地函数非常简单。
(1) System.loadLibrary("Native");加载库文件
(2) 使用Native声明本地函数。

```
package com.jiesean.jnidemo;

import android.app.Activity;
import android.os.Bundle;

public class MainActivity extends Activity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
    }

    static {
        //加载本地动态库
        //JNI为本地动态库的名称，在win中会自动扩展为.dll,在linux中会自动扩展为.so
        System.loadLibrary("jnidemo");
    }

    //使用native声明本地set函数
    private native void set(int i);
    //使用native声明本地get函数
    private native int get();
}
```
#####2. javah静态注册,生成.h头文件

Make这个工程，找到MainActivity生成的.class文件，目录在本工程目录下的build/intermediates/classes/debug/包名这个目录下，以我的为例：
```
build/intermediates/classes/debug/com/jiesean/jnidemo/MainActivity.class

```
退回到工程的main目录下，进行javah生成.h头文件
命令的格式为
```
javah-d jni -classpath <SDK_android.jar path>:<APP_classes path> com.jiesean.jnidemo.MainActivity
特别注意：<SDK_android.jar>:<APP_classes>中间的冒号为linux下的用法，windows平台下使用分号。
```
以我的为例：
```
javah -d jni -classpath ../../../../../bin/Android/Sdk/platforms/android-24/android.jar:../../build/intermediates/classes/debug com.jiesean.jnidemo.MainActivity
```
这样在android工程目录下看到：

![工程目录](http://upload-images.jianshu.io/upload_images/1806858-4d5bc2a02d70987d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
```
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_jiesean_jnidemo_MainActivity */

#ifndef _Included_com_jiesean_jnidemo_MainActivity
#define _Included_com_jiesean_jnidemo_MainActivity
#ifdef __cplusplus

/*
 * Class:     com_jiesean_jnidemo_MainActivity
 * Method:    set
 * Signature: (I)V
 */
JNIEXPORT void JNICALL Java_com_jiesean_jnidemo_MainActivity_set
  (JNIEnv *, jobject, jint);

/*
 * Class:     com_jiesean_jnidemo_MainActivity
 * Method:    get
 * Signature: ()I
 */
JNIEXPORT jint JNICALL Java_com_jiesean_jnidemo_MainActivity_get
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif


```

#####3. 配置NDK

(1) local.properties中填写NDK路径
```
ndk.dir=/home/tstz4/bin/Android/Sdk/ndk-bundle
sdk.dir=/home/tstz4/bin/Android/Sdk
```
(2) jnidemo/build.gradle中加入ndk
```
defaultConfig {
        applicationId "com.jiesean.jnidemo"
        minSdkVersion 17
        targetSdkVersion 24
        versionCode 1
        versionName "1.0"

        ndk {
            moduleName "jnidemo"
            ldLibs "log", "z", "m"
            abiFilters "armeabi", "armeabi-v7a", "x86"
        }
    }
```
(3) gradle.properties文件中添加,如果不存在在工程根目录下创建他。
```
android.useDeprecatedNdk=true
```
#####4. 生成动态库
配置好ndk后，再次make工程，如果显示没有错误，说明生成动态库成功。
>注意：在linux下为.so文件，在windows下为.dll文件

android studio的动态库的输出目录为：
```
/build/intermediates/ndk/debug/lib
```
#####5. 安装运行，得到输出结果
```
09-05 09:18:41.744 2378-2378/com.jiesean.jnidemo D/MainActivity: 得到native函数的返回值11
```
#####6. 总有些坑要我们去踩
(1) javah命令使用时，前面不添加SDK_android.jar path，会导致Activity.class找不到的错误。
(2) javah命令使用时，SDK_android.jar path和APP_classes path之间冒号和分号的误用，这里前面已经提到。
(3) linux下动态库会是libjnidemo.so,但是加载的时候不能根据写这个名字，应该根据ndk中声明的来写。
```
 ndk {
            moduleName "jnidemo"
            ldLibs "log", "z", "m"
            abiFilters "armeabi", "armeabi-v7a", "x86"
        }
```
否则会出现
```
java.lang.UnsatisfiedLinkError: com.android.tools.fd.runtime
```

#####小结

本文主要说明了在android  studio中使用JNI调用native方法的简单实例。
还有一点不得不说，遇到问题stackoverflow中去查，大部分很快就解决了，中文资料真的很浪费时间。